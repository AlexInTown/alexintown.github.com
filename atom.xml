<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AlexInTown's Notes]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://alexintowm.com/"/>
  <updated>2016-03-31T11:07:35.579Z</updated>
  <id>http://alexintowm.com/</id>
  
  <author>
    <name><![CDATA[AlexInTown]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python工程远程部署与调试]]></title>
    <link href="http://alexintowm.com/2016/03/31/python-remote-deployment-debugging/"/>
    <id>http://alexintowm.com/2016/03/31/python-remote-deployment-debugging/</id>
    <published>2016-03-31T09:46:00.000Z</published>
    <updated>2016-03-31T11:07:35.579Z</updated>
    <content type="html"><![CDATA[<p>对于机器学习的应用场景，Python工程往往依赖各种算法框架，而其依赖的底层库往往是与平台高度相关的，没有经验会比较耗费精力。在不同平台分别进行开发和部署Python工程的时候，装两份环境实在是一件痛苦并且效率不高的选择。那么退而求其次，可能有人选择在windows平台做开发工作，没有IDE的debug环境的条件下，直接在linux平台上测试。而这样要调通往往很有挑战性（特别是调用你不太熟悉的包出错的时候）。</p>
<p>PyCharm 是一个非常好用的IDE，编辑提示功能比较智能，并且对于各种类型的工程支持很全，插件完备。如果你只想在windows或者mac上使用PyCharm 开发（不测试运行），并且在安装了很多Python机器学习包的linux机器进行部署，又能获得IDE下debug的便利，一切是不是太完美？</p>
<p>其实使用PyCharm进行少量的设置，就能实现Python远程开发和调试，获得与本地开发测试一致的体验。</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先进行远程Python环境的设置，配置安装所需的包，为后面配置记录Python所在路径(如/usr/local/bin/python)。如果要使用virtualenv，注意替换成对应python可执行文件路径。<br>将工程上传到远程环境某个目录中，例如/home/xxxx/workspace/中， 或者使用git clone到远程服务器上。</p>
<h2 id="u8FDC_u7A0BPython_u73AF_u5883_u8BBE_u7F6E"><a href="#u8FDC_u7A0BPython_u73AF_u5883_u8BBE_u7F6E" class="headerlink" title="远程Python环境设置"></a>远程Python环境设置</h2><p>PyCharm下打开菜单项，Settings-&gt;Deployment 点击‘+’添加新环境。<br>使用SFTP形式进行服务器连接：<br><img src="http://7xsh66.com1.z0.glb.clouddn.com/hexo/python-remote-deployment-debugging/add_server.png" alt="添加远程服务器"><br>配置连接的host和port（SSH：22），以及对应的用户名和密码。Root path是远程机器对应的代码根目录，注意如果使用home目录，不要使用‘~’。<br><img src="http://7xsh66.com1.z0.glb.clouddn.com/hexo/python-remote-deployment-debugging/add_server_detail.png" alt="添加远程服务器选项"><br>高级设置将编码方式设置成UTF-8.<br><img src="http://7xsh66.com1.z0.glb.clouddn.com/hexo/python-remote-deployment-debugging/advanced_server_setting.png" alt="添加远程服务器高级设置"></p>
<h2 id="u5DE5_u7A0B_u8DEF_u5F84_u6620_u5C04"><a href="#u5DE5_u7A0B_u8DEF_u5F84_u6620_u5C04" class="headerlink" title="工程路径映射"></a>工程路径映射</h2><p>配置工程路径映射关系，本地配置当前工程根目录，远程配置对应的工程目录名。工程根目录+工程目录名，在这个例子中即为/home/xxxx/workspace/project-path。<br><img src="http://7xsh66.com1.z0.glb.clouddn.com/hexo/python-remote-deployment-debugging/project_path_mapping.png" alt="配置工程路径映射"></p>
<h2 id="u4EE3_u7801_u81EA_u52A8_u4E0A_u4F20"><a href="#u4EE3_u7801_u81EA_u52A8_u4E0A_u4F20" class="headerlink" title="代码自动上传"></a>代码自动上传</h2><p>工程路径的映射关系建立后，可以实现Ctrl+S保存时，代码自动上传到远程服务器。<br><img src="http://7xsh66.com1.z0.glb.clouddn.com/hexo/python-remote-deployment-debugging/tools_deploy_option.png" alt="代码自动上传选项"><br>代码上传设置：<br><img src="http://7xsh66.com1.z0.glb.clouddn.com/hexo/python-remote-deployment-debugging/deploy_upload_code.png" alt="代码自动上传设置"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>对于使用theano，Caffe等GPU计算环境的工程，输出也可以返回到PyCharm的控制台中，使用PyCharm IDE进行远程调试的确能够大大提高效率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于机器学习的应用场景，Python工程往往依赖各种算法框架，而其依赖的底层库往往是与平台高度相关的，没有经验会比较耗费精力。在不同平台分别进行开发和部署Python工程的时候，装两份环境实在是一件痛苦并且效率不高的选择。那么退而求其次，可能有人选择在windows平台做开]]>
    </summary>
    
      <category term="pycharm" scheme="http://alexintowm.com/tags/pycharm/"/>
    
      <category term="python" scheme="http://alexintowm.com/tags/python/"/>
    
      <category term="python" scheme="http://alexintowm.com/categories/python/"/>
    
      <category term="tools" scheme="http://alexintowm.com/categories/python/tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基础图论-最短路径算法总结]]></title>
    <link href="http://alexintowm.com/2016/02/19/graph-shortest-path/"/>
    <id>http://alexintowm.com/2016/02/19/graph-shortest-path/</id>
    <published>2016-02-19T07:35:00.000Z</published>
    <updated>2016-02-23T07:01:47.873Z</updated>
    <content type="html"><![CDATA[<p>最短路径问题是图论中基础问题，本文对多种最短路径算法原理进行简单总结，并从实现和复杂度上进行比较。</p>
<h2 id="u5355_u6E90_u6700_u77ED_u8DEF_u5F84"><a href="#u5355_u6E90_u6700_u77ED_u8DEF_u5F84" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><p>单源最短路径问题: 给定图G，源点s，求s到其他各个顶点的最短路径。</p>
<h3 id="Bellman-Ford_u7B97_u6CD5"><a href="#Bellman-Ford_u7B97_u6CD5" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>图G中如果不存在负环，考虑s出发到其他各个节点，其最短路径将形成一个树（所谓前趋子图）。且该树的最大深度为|V|-1。那么可以通过“松弛”技术来更新其他点到s的距离。</p>
<blockquote>
<p>松弛操作<br>dist[v] = min(dist[u] + e(u,v), dist[v])</p>
</blockquote>
<p>因为无负环情况下，路径最长边数为|V|-1，那么每次对所有dist[v]进行松弛，最多执行|V|-1次将收敛。</p>
<p>倘若第|V|次对所有顶点进行松弛操作，仍有更新，那么该图中存在负环。<br>所以Bellman-Ford算法也可以用来检测图中是否有负环。</p>
<p>复杂度分析比较简单，每次松弛操作O(|E|)，总时间复杂度O(|V||E|)。</p>
<h3 id="Bellman-Ford_u7B97_u6CD5C++_u4EE3_u7801"><a href="#Bellman-Ford_u7B97_u6CD5C++_u4EE3_u7801" class="headerlink" title="Bellman-Ford算法C++代码"></a>Bellman-Ford算法C++代码</h3><h3 id="Dijkstra_u7B97_u6CD5"><a href="#Dijkstra_u7B97_u6CD5" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra 算法适用于无负环图。考虑Bellman-Ford算法中，每次对所有边进行松弛操作，对于已算出最短路径的顶点是一种浪费。</p>
<p>而Dijkstra算法维护一个点集V’，初始为{s}，每次将当前最短路径的点加入其中，然后从该点出发，对未加入点进行松弛操作。</p>
<p>这样通过|V|-1次加入顶点的操作，就能获得从s点到其他点的最短路径。</p>
<p>当图中所有权重相等时，Dijkstra算法退化成BFS算法。</p>
<h3 id="Dijkstra_u7B97_u6CD5_u7B80_u5355_u8BC1_u660E"><a href="#Dijkstra_u7B97_u6CD5_u7B80_u5355_u8BC1_u660E" class="headerlink" title="Dijkstra算法简单证明"></a>Dijkstra算法简单证明</h3><p>定义：V为顶点全集，dist[v]表示算法执行时，顶点v的路径长度。<br>下面证明：在Djikstra算法中，每次向V’加入顶点u后，dist[u]的值等于最短路径长度。<br>初始：V’={s} 显然成立<br>保持：考虑在V-V’中，u为当前路径长度最短的点，v为除u之外任意点，先证明u必然先于v加入V’。<br>假设v先加入V’，那<br>终止：</p>
<h3 id="Dijkstra_u7B97_u6CD5C++_u4EE3_u7801"><a href="#Dijkstra_u7B97_u6CD5C++_u4EE3_u7801" class="headerlink" title="Dijkstra算法C++代码"></a>Dijkstra算法C++代码</h3><h3 id="Dijkstra_u7B97_u6CD5_u590D_u6742_u5EA6"><a href="#Dijkstra_u7B97_u6CD5_u590D_u6742_u5EA6" class="headerlink" title="Dijkstra算法复杂度"></a>Dijkstra算法复杂度</h3><p>松弛操作的总开销为O(|E|)。</p>
<p>每次选取当前最短路径的点，线性扫描的方式为O(|V|)，采用二叉堆的开销为O(log|V|)。<br>两种方式总开销分别为O(|V|^2)和O(|V|log|V|)。</p>
<p>所以线性扫描，总时间复杂度为O(|E|) + O(|V|^2) = O(|V|^2)</p>
<p>而采用二叉堆在松弛后需要进行O(E)次入队操作，每次开销为O(log|V|)，故总复杂度为O(|E|) + O(|V|log|V|) + O(|E|log|V|) = O(|E|log|V|)。</p>
<h3 id="SPFA__u7B97_u6CD5"><a href="#SPFA__u7B97_u6CD5" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h3><p>SPFA(Shortest Path Faster Algorithm) 算法，在Bellman-Ford算法上加了一个队列优化。<br>在图存在负环的情况下，Dijkstra算法不适用，而Bellman-Ford算法复杂度太高，该算法就是较好的选择。</p>
<p>算法维护一个队列，该队列初始状态下将s入队，每次用出队的顶点u进行松弛操作；如果有一个顶点v松弛成功更新了（比当前距离小），并且不在当前队列中，那么将v入队尾。</p>
<p>在没有负环的情况下，每次入队能够保证减小dist[v]，直到队列为空，最终能够获得所有顶点的最短路径。算法复杂度O(n*|E|)，n为顶点平均入队次数，而入队次数取决于图的边权分布。算法运行时间不稳定，最坏的情况下，为Bellman-Ford算法。</p>
<p>可能有负环的情况下，记录每个顶点的入队次数，如果存在顶点入队次数达到|V|，那么一定存在负环。</p>
<p>实际运用中通过SLF(Smallest Label First)或LLL(Large Label Last)优化，一般比原算法有一定提升。关于SPFA的详细介绍：<br>//TODO</p>
<h3 id="SPFA_u7B97_u6CD5C++_u4EE3_u7801"><a href="#SPFA_u7B97_u6CD5C++_u4EE3_u7801" class="headerlink" title="SPFA算法C++代码"></a>SPFA算法C++代码</h3><h2 id="u591A_u6E90_u6700_u77ED_u8DEF_u5F84"><a href="#u591A_u6E90_u6700_u77ED_u8DEF_u5F84" class="headerlink" title="多源最短路径"></a>多源最短路径</h2><h3 id="Floyd-Washall__u7B97_u6CD5"><a href="#Floyd-Washall__u7B97_u6CD5" class="headerlink" title="Floyd-Washall 算法"></a>Floyd-Washall 算法</h3><p>给定一个图G，任意两点u,v的路径可能经过所有其他点。该算法利用了动态规划思想，求图中任意两点最短路径的问题。</p>
<blockquote>
<p>考虑G中点(v0, v1, v2, …, vn)的前K个，uv中经过前K个顶点的最短距离dist[k][u][v]可以分解为：</p>
<ol>
<li>经过点k，那么dist[k][u][v] = dist[k-1][u][k] + dist[k-1][k][v]</li>
<li>不经过k，那么dist[k][u][v] = dist[k-1][u][v]<br>递推式: dist[k][u][v] = min( dist[k-1][u][k] + dist[k-1][k][v], dist[k-1][u][v])<br>有了上述递推公式，就可以自底向上进行动态规划求解。算法复杂度为O(|V|^3)。</li>
</ol>
</blockquote>
<h2 id="u6700_u77ED_u8DEF_u5F84_u7684_u8FD8_u539F"><a href="#u6700_u77ED_u8DEF_u5F84_u7684_u8FD8_u539F" class="headerlink" title="最短路径的还原"></a>最短路径的还原</h2><p>对于每次松弛操作，为每个顶点v记录father[v] = u，表示当前路径最后一步，u经e(u, v)到达v。<br>在最短路径算法完成后，沿father[v]进行回溯就可以还原出整条路径。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最短路径问题是图论中基础问题，本文对多种最短路径算法原理进行简单总结，并从实现和复杂度上进行比较。</p>
<h2 id="u5355_u6E90_u6700_u77ED_u8DEF_u5F84"><a href="#u5355_u6E90_u6700_u77ED_u8DE]]>
    </summary>
    
      <category term="Bellman-Ford" scheme="http://alexintowm.com/tags/Bellman-Ford/"/>
    
      <category term="Dijkstra" scheme="http://alexintowm.com/tags/Dijkstra/"/>
    
      <category term="Floyd-Washall" scheme="http://alexintowm.com/tags/Floyd-Washall/"/>
    
      <category term="SPFA" scheme="http://alexintowm.com/tags/SPFA/"/>
    
      <category term="最短路径" scheme="http://alexintowm.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="algorithm" scheme="http://alexintowm.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基础图论-Prim, Kruskal算法证明及实现]]></title>
    <link href="http://alexintowm.com/2016/02/19/graph-minimum-spanning-tree/"/>
    <id>http://alexintowm.com/2016/02/19/graph-minimum-spanning-tree/</id>
    <published>2016-02-19T07:35:00.000Z</published>
    <updated>2016-02-23T01:50:00.681Z</updated>
    <content type="html"><![CDATA[<p>给定带权无向连通图G(V, E)，最小生成树指所有边权重之和最小的生成树。Prim算法和Kruskal算法分别采用不同的贪心策略，Prim算法适用于稠密图，Kruskal算法适用于稀疏图。</p>
<h2 id="Prim__u7B97_u6CD5"><a href="#Prim__u7B97_u6CD5" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>Prim 算法维护一个子图G’，对应的点集为V’，边集E’，表示生成树过程中已经包括的顶点和边；通过贪心地添加在V-V’中代价最小的顶点，同时更新剩下顶点的代价，最终生成目标树。</p>
<h3 id="Prim_u7B97_u6CD5_u7684_u8BC1_u660E"><a href="#Prim_u7B97_u6CD5_u7684_u8BC1_u660E" class="headerlink" title="Prim算法的证明"></a>Prim算法的证明</h3><ol>
<li>初始情况下，G’仅有一个顶点，所以G’为一棵最小生成树，并且G’是最终的最小生成树T的子图。</li>
<li>当前G’是T的子图，V-V’中代价最小的顶点为u，其代价为u到V’中最近的顶点v边权e。<br>假设此次添加的不是e(u, v)，而在最终的T中，连通G’和 T-G’的边为e’。那么将e添加到T中（形成环），并删去e’能够得到更小的权重总和，这与T为最小生成树矛盾。</li>
</ol>
<p>所以e必出现在T中，G’添加了顶点u和边e后，依然是T的子图。<br>综上所述，通过|V|-1次添加顶点后，生成的子图为最小生成树。</p>
<h3 id="Prim_u7B97_u6CD5_u7684C++_u5B9E_u73B0"><a href="#Prim_u7B97_u6CD5_u7684C++_u5B9E_u73B0" class="headerlink" title="Prim算法的C++实现"></a>Prim算法的C++实现</h3><p>从一个例子来看Prim算法的实现，<a href="http://poj.org/problem?id=1258" target="_blank" rel="external">poj 1258 Ari-Net</a>。<br>题意很好理解：铺设光纤网络，让整个网络是连通的，并且使得光纤的总开销最小。基本上是对最小生成树的直接运用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN];    <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> min_cost[MAXN];   <span class="comment">// 顶点的加入代价</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * N);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        min_cost[i] = <span class="number">100000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_cost_val, min_cost_v;</span><br><span class="line">    min_cost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        min_cost_v = -<span class="number">1</span>;</span><br><span class="line">        min_cost_val = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; ++j)&#123;      <span class="comment">// 寻找在V-V'中加入代价最小的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; min_cost_val &gt; min_cost[j])&#123;</span><br><span class="line">                min_cost_val = min_cost[j];</span><br><span class="line">                min_cost_v = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min_cost_v == -<span class="number">1</span>) <span class="keyword">break</span>;  <span class="comment">// 都已经加入，结束</span></span><br><span class="line">        res += min_cost_val;         <span class="comment">// 更新总代价</span></span><br><span class="line">        visited[min_cost_v] = <span class="number">1</span>;     <span class="comment">// 更新加入的标记</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; ++j)&#123;      <span class="comment">// 更新剩下顶点的加入代价</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; min_cost[j] &gt; g[min_cost_v][j])&#123;</span><br><span class="line">                min_cost[j] = g[min_cost_v][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; N; ++j)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;g[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, prim());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Prim_u7B97_u6CD5_u590D_u6742_u5EA6_u5206_u6790"><a href="#Prim_u7B97_u6CD5_u590D_u6742_u5EA6_u5206_u6790" class="headerlink" title="Prim算法复杂度分析"></a>Prim算法复杂度分析</h3><p>上述算法实现中，每次从V-V’中寻找最小代价的点，更新剩下顶点，时间复杂度为O(|V|)。添加顶点次数|V|-1，总的时间复杂度为O(|V|^2)。</p>
<p>若采用邻接表，对于更新剩下顶点的时间总开销，减小为O(|E|)，但寻找最小代价的点没有改进。</p>
<p>若采用邻接表，二叉堆作为优先队列，剩余顶点代价更新次数O(|E|)次，每次开销O(log|V|)；取最小代价点的总开销为O(|V|log|V|); 故时间复杂度为O(|E|log|V| + |V|log|V|) = O(|E|log|V|)。</p>
<p>若采用邻接表，斐波拉契数堆，剩余顶点代价更新总开销为O(|E|)，因为斐波拉契堆插入开销为O(1)；取最小代价点单次为O(log|V|)，总开销O(|V|log|V|)；故时间复杂度为O(|E| + |V|log|V|)。</p>
<h2 id="Kruskal_u7B97_u6CD5"><a href="#Kruskal_u7B97_u6CD5" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>Kruskal 算法，先对所有边按边权排序(从小到大)，维护一个子图G’，对于每个边e(u, v)，若能保证加入后子图中没有环，则将该边加入子图。<br>对于连通子图中的顶点，可以使用并查集来标识。如果边e的顶点u，v在同一个集合中，加入e后必然会形成环路，反之则可以加入e。</p>
<h3 id="Kruskal_u7B97_u6CD5_u7684_u8BC1_u660E"><a href="#Kruskal_u7B97_u6CD5_u7684_u8BC1_u660E" class="headerlink" title="Kruskal算法的证明"></a>Kruskal算法的证明</h3><p>与Prim算法类似，采用数学归纳法证明：</p>
<ol>
<li>初始边集X为空，所有顶点都各成一个连通子图，并且每个子图都是最后的最小生成树T的子图。</li>
<li>假设当前每个连通子图都是T的子图，考虑连接各个子图之间的边，设最小的为e(u, v)。那么e(u, v)将出现在T中：因为若加入的是e’，而e不被包含在T中，加入e后可以将e’删除，并且保持生成树的性质且总代价比T更小。加入了e后，各连通子图依旧是T的子图。</li>
</ol>
<p>综上，每次加入边能保证每个子图都是最小生成树T的子图，通过|V|-1次加入操作就能生成最小生成树。</p>
<h3 id="Kruskal_u7B97_u6CD5_u7684C++_u5B9E_u73B0"><a href="#Kruskal_u7B97_u6CD5_u7684C++_u5B9E_u73B0" class="headerlink" title="Kruskal算法的C++实现"></a>Kruskal算法的C++实现</h3><p>我们看另一个例子，<a href="http://poj.org/problem?id=2377" target="_blank" rel="external">poj 2377 Bad Cowtractors</a>。<br>题意：铺设网络，使得网络连通并开销最大，输出网络开销。将边的处理顺序变成从大到小即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">struct</span> Edge&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; b.w;  <span class="comment">// 自定义比较函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1000</span>];</span><br><span class="line">Edge edges[<span class="number">20000</span>];</span><br><span class="line"><span class="comment">// 并查集操作，如果a,b在不同集合，合并集合，返回集合id；否则返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unifind</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = arr[a];</span><br><span class="line">    <span class="keyword">int</span> fb = arr[b];</span><br><span class="line">    <span class="keyword">while</span>(fa&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        a = fa;</span><br><span class="line">        fa = arr[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fb&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        b = fb;</span><br><span class="line">        fb = arr[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="keyword">return</span> -<span class="number">1</span>;   <span class="comment">// 同一个集合</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(fa &lt; fb)&#123;            <span class="comment">// 按秩合并</span></span><br><span class="line">        arr[a] += fb;</span><br><span class="line">        arr[b] = a;</span><br><span class="line">        res = a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        arr[b] += fa;</span><br><span class="line">        arr[a] = b;</span><br><span class="line">        res = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(edges, edges+M);   <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; ++i)&#123; <span class="comment">// 从小到大处理加入边</span></span><br><span class="line">        <span class="keyword">if</span>(unifind(edges[i].u, edges[i].v) &gt;= <span class="number">0</span>)&#123;  </span><br><span class="line">            res += edges[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; <span class="number">0</span>) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; ++i)&#123;</span><br><span class="line">        Edge &amp;e = edges[i];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;e.u, &amp;e.v, &amp;e.w);</span><br><span class="line">        e.u--; e.v --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(arr, -<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) *N);  <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, kruskal());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal_u7B97_u6CD5_u590D_u6742_u5EA6_u5206_u6790"><a href="#Kruskal_u7B97_u6CD5_u590D_u6742_u5EA6_u5206_u6790" class="headerlink" title="Kruskal算法复杂度分析"></a>Kruskal算法复杂度分析</h3><p>Kruskal算法实现起来直接简单，开销取决于排序操作O(|E|log|E|) = O(|E|log|V|)。图较为稀疏的时候，比Prim算法更有优势。</p>
<h2 id="Prim_uFF0CKruskal_u7B97_u6CD5_u6BD4_u8F83"><a href="#Prim_uFF0CKruskal_u7B97_u6CD5_u6BD4_u8F83" class="headerlink" title="Prim，Kruskal算法比较"></a>Prim，Kruskal算法比较</h2><p>对于稀疏图，首选Kruskal算法。因为基于邻接表和二叉堆，实际实现中，效率一般比不上直接用快排。而采用斐波拉契堆，理论上均摊效率虽高，但实现起来也较复杂。</p>
<p>对于稠密图，Prim算法没必要采用邻接表+堆，反而O(|V|^2)更为简单高效。</p>
<p>上述两种C++实现，分别对稠密图和稀疏图有较好的适用性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>给定带权无向连通图G(V, E)，最小生成树指所有边权重之和最小的生成树。Prim算法和Kruskal算法分别采用不同的贪心策略，Prim算法适用于稠密图，Kruskal算法适用于稀疏图。</p>
<h2 id="Prim__u7B97_u6CD5"><a href="#P]]>
    </summary>
    
      <category term="Kruskal" scheme="http://alexintowm.com/tags/Kruskal/"/>
    
      <category term="Prim" scheme="http://alexintowm.com/tags/Prim/"/>
    
      <category term="最小生成树" scheme="http://alexintowm.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="algorithm" scheme="http://alexintowm.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Wooden Sticks POJ 1065]]></title>
    <link href="http://alexintowm.com/2015/11/05/dp-poj-1065-wooden-sticks/"/>
    <id>http://alexintowm.com/2015/11/05/dp-poj-1065-wooden-sticks/</id>
    <published>2015-11-05T13:53:12.000Z</published>
    <updated>2015-12-07T06:50:08.322Z</updated>
    <content type="html"><![CDATA[<h2 id="u9898_u76EE_u5927_u610F"><a href="#u9898_u76EE_u5927_u610F" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一台机器要对n根木棍进行加工，每根木棍用(l, w)的元组来表示，l为木棍的长度，w为木棍的重量；机器有如下特性：</p>
<ol>
<li>每次设置的时间延迟为1分钟(开始时必须设置一次);</li>
<li>两根木棍(l1, w1), (l2, w2)依次输送给机器，并且满足条件(l1&lt;=l2，w1&lt;=w2)时，对于(l2, w2)无需重新设置。<br>现给出n根木棍的(l, w)，求这组木棍通过该机器的最小设置时间。</li>
</ol>
<h3 id="u8F93_u5165"><a href="#u8F93_u5165" class="headerlink" title="输入"></a>输入</h3><p>第一行为正整数T，表示测试数据个数<br>每个测试数据第一行n，1 &lt;= n &lt;= 5000；<br>接下来第二行为2n个数，l1, w1, l2, w2 …. ln, wn</p>
<h3 id="u8F93_u51FA"><a href="#u8F93_u51FA" class="headerlink" title="输出"></a>输出</h3><p>对每个测试数据输出最小设置时间</p>
<h2 id="u521D_u6B65_u5206_u6790"><a href="#u521D_u6B65_u5206_u6790" class="headerlink" title="初步分析"></a>初步分析</h2><p>要设置时间最小，等价于求满足特性2的棍子序列的最少个数。长度和重量有2个维度，可以先对序列进行排序，第一排序字段为长度，次要排序字段为重量。例：</p>
<blockquote>
<p>原始序列: (4,9) (5,2) (2,1) (3,5) (1,4)<br>排序后为：(1,4) (2,1) (3,5) (4,9) (5,2)</p>
</blockquote>
<p>这样排序能够保证长度l是非递减序列。此时，找出最小设置时间，转化为重量w的最小的非递减序列的个数。</p>
<blockquote>
<p>重量序列：4, 1, 5, 9, 2</p>
</blockquote>
<p>简单验证可得到，该例最小重量序列的个数为2，两个序列分别为(4, 5, 9) (1, 2)</p>
<h2 id="u8D2A_u5FC3_u6CD5"><a href="#u8D2A_u5FC3_u6CD5" class="headerlink" title="贪心法"></a>贪心法</h2><p>对于上述重量序列，易想到贪心算法：</p>
<blockquote>
<p>Step 0. times = 0<br>Step 1. 对于当前序列，求出最长递增子序列LIS<br>Step 2. 从当前序列中剔除该LIS，times++<br>Step 3. 直到序列为空</p>
</blockquote>
<p>给定一组子序列，子序列被剔除的顺序与最终结果无关；并且每次剔除序列时，LIS能够保证不比其他方法差。<br>假设一次提取子序列没有使用最长非递减子序列，剩下的元素可能导致子序列的个数增加。因此贪心法能够得到正确的结果。</p>
<h3 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, N;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idx;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="keyword">struct</span> Comp&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vi[a] &lt; vi[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; vi, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; parent, <span class="keyword">int</span> &amp;lastIdx)</span></span>&#123;</span><br><span class="line">    parent.resize(vi.size());</span><br><span class="line">    idx.resize(vi.size());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; vi.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = upper_bound(idx.begin(), idx.begin()+ res, i,Comp())-idx.begin();</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">0</span>) parent[i] = idx[j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> parent[i] = -<span class="number">1</span>;</span><br><span class="line">        idx[j] = i;</span><br><span class="line">        <span class="keyword">if</span>(j == res) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res &gt; <span class="number">0</span>) lastIdx = idx[res-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vi, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;parent, <span class="keyword">int</span> lastIdx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(lastIdx &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        vi[lastIdx] = INT_MIN;</span><br><span class="line">        lastIdx = parent[lastIdx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vi[i] != INT_MIN)</span><br><span class="line">            vi[j++] = vi[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vi.resize(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;  vpii;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; T; ++t)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">        vpii.clear();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;pii.first&gt;&gt;pii.second;</span><br><span class="line">            vpii.push_back(pii);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vpii.begin(), vpii.end());</span><br><span class="line">        vi.clear();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            vi.push_back(vpii[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastIdx;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(vi.size())&#123;</span><br><span class="line">            LIS(vi, parent, lastIdx);</span><br><span class="line">            removeLIS(vi, parent, lastIdx);</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u590D_u6742_u5EA6_u5206_u6790"><a href="#u590D_u6742_u5EA6_u5206_u6790" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>排序时间复杂度为O(nlog(n))。<br>假设求k次LIS，每次平均O(n/k log(n/k))，上界O(nlog(n))。<br>每个元素最多被剔除一次，但需要拷贝后续元素，最差情况为递减序列，复杂度为O(n^2)。<br>最差时间复杂度为O(n^2)。</p>
<h2 id="u6700_u957F_u4E25_u683C_u9012_u51CF_u5B50_u5E8F_u5217"><a href="#u6700_u957F_u4E25_u683C_u9012_u51CF_u5B50_u5E8F_u5217" class="headerlink" title="最长严格递减子序列"></a>最长严格递减子序列</h2><p>假设最小的非递减子序列个数为x，而最长严格递减子序列为L。会有L==x，下面来证明这一点。</p>
<h3 id="u8BC1_u660E"><a href="#u8BC1_u660E" class="headerlink" title="证明"></a>证明</h3><h4 id="L__26lt_3B_x__u4E0D_u6210_u7ACB"><a href="#L__26lt_3B_x__u4E0D_u6210_u7ACB" class="headerlink" title="L &lt; x 不成立"></a>L &lt; x 不成立</h4><p>非递减子序列的个数最小为x，基于上述对贪心法的正确性分析，我们可以认为这些非递减子序列是由不断的LIS算法剔除得到的。</p>
<blockquote>
<p>该序列组设为 s1, s2, .. ,si, .. sx<br>每个si末尾元素为 e1, e2, .. , ei, .. ex</p>
</blockquote>
<p>不妨设e1 e2 e3, … ex 的顺序，为排序后在重量序列中的顺序。明显有：</p>
<blockquote>
<p>e1 &gt; e2 &gt; .. &gt;ei … &gt; ex</p>
</blockquote>
<p>否则与LIS的定义矛盾。e1 到 ex 已经有x个元素符合严格递减子序列的定义，L &gt;= x; L &lt; x不成立。</p>
<h4 id="L__26gt_3B_x__u4E0D_u6210_u7ACB"><a href="#L__26gt_3B_x__u4E0D_u6210_u7ACB" class="headerlink" title="L &gt; x 不成立"></a>L &gt; x 不成立</h4><p>由于递减序列L中的元素，不能出现在同一个非递减序列中。假设L大于x，那么必然有两个L中的元素出现在某个费递减序列中。矛盾，故L &gt; x不成立。</p>
<p>因此L==x，直接求排序后重量序列中的严格递减序列的长度，即为x。</p>
<h3 id="u4EE3_u7801-1"><a href="#u4EE3_u7801-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, N;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idx;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi; </span><br><span class="line"><span class="keyword">struct</span> Comp&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vi[a] &gt;= vi[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; vi)</span></span>&#123;</span><br><span class="line">    idx.resize(vi.size());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; vi.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = upper_bound(idx.begin(), idx.begin()+ res, i,Comp())-idx.begin();</span><br><span class="line">        idx[j] = i;</span><br><span class="line">        <span class="keyword">if</span>(j == res) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;  vpii;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; T; ++t)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">        vpii.clear();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;pii.first&gt;&gt;pii.second;</span><br><span class="line">            vpii.push_back(pii);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vpii.begin(), vpii.end());</span><br><span class="line">        vi.clear();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            vi.push_back(vpii[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = LIS(vi);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u590D_u6742_u5EA6_u5206_u6790-1"><a href="#u590D_u6742_u5EA6_u5206_u6790-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>求LDS与LIS的时间复杂度一致，为O(nlog(n)).</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u9898_u76EE_u5927_u610F"><a href="#u9898_u76EE_u5927_u610F" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一台机器要对n根木棍进行加工，每根木棍用(l,]]>
    </summary>
    
      <category term="DP" scheme="http://alexintowm.com/tags/DP/"/>
    
      <category term="LDS" scheme="http://alexintowm.com/tags/LDS/"/>
    
      <category term="LIS" scheme="http://alexintowm.com/tags/LIS/"/>
    
      <category term="greedy" scheme="http://alexintowm.com/tags/greedy/"/>
    
      <category term="algorithm" scheme="http://alexintowm.com/categories/algorithm/"/>
    
      <category term="POJ" scheme="http://alexintowm.com/categories/algorithm/POJ/"/>
    
  </entry>
  
</feed>
